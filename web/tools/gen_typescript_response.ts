var path = require("path");
var BuiltinModule = require("module");
global.XMLHttpRequest = require("xhr2");

XMLHttpRequest.prototype.send = function(body) {
  return "";
};

//Resolve our vue files with a blank.ts, this will allow the code to execute.
var Module = module.constructor.length > 1 ? module.constructor : BuiltinModule;
var oldResolveFilename = Module._resolveFilename;
Module._resolveFilename = function(request, parentModule, isMain, options) {
  if (request.includes(".vue")) return "blank.ts";
  if (request.includes("@")) return path.join(__dirname, request.replace("@/", "../src/") + ".js");
  return oldResolveFilename.call(this, request, parentModule, isMain, options);
};

import { readFileSync, writeFileSync, unlinkSync } from "fs";
import { QuestionConverter } from "survey-creator";
const filePath = path.join(__dirname, "../../../src/types/survey-primary.ts");

import * as Survey from "survey-vue";

import { addQuestionTypes } from "../src/survey/question-types/question-types";
const json = readFileSync("../src/survey-primary.json").toString();

const generateQuestionNamesEnum = survey => {
  console.log("Generating Question Names Enum..");
  let questionNames = [];
  let data = `// This is autogenerated by tools/gen_typescript_response. on ${new Date().toISOString()} \n`;
  data += `export enum SurveyQuestionNames {\n`;
  survey.getAllQuestions(false, true).forEach(function(question) {
    if (questionNames.includes(question.name)) {
      console.log(`Warning: Found duplicate questionName: ${question.name}. Skipping.`);
      return;
    }
    if (question.name.includes("?") || question.name.includes("-"))
      data += `\t\"${question.name}\" = \"${question.name}\",\n`;
    else data += `\t${question.name} = \"${question.name}\",\n`;
    questionNames.push(question.name);
  });
  data += "}\n";
  writeFileSync(filePath, data, { encoding: "utf8", flag: "w" });
};

const getTypescriptDefinitionLine = question => {
  const questionName =
    question.name.includes("?") || question.name.includes("-")
      ? `\"${question.name}\"`
      : `${question.name}`;
  let questionType;
  switch (question.getType()) {
    //TODO use bound strings here.
    case "address":
      questionType = "AddressAndContact";
      break;
    case "contactinfo":
      questionType = "ContactInfo";
      break;
    case "personname":
      questionType = "PersonName";
      break;
    default:
      questionType = "string";
      break;
  }
  return `\t${questionName}?: ${questionType}\n`;
};

//TODO we have seperated interfaces, lets NEST them.
const generateQuestionInterfaces = survey => {
  console.log("Generating Interfaces..");
  const panelQuestionNames = [];
  let data = "//Generated interfaces here.\n";

  survey
    .getAllQuestions(false, true)
    .filter(x => x.getType() === "paneldynamic")
    .forEach(function(question) {
      if (question?.panels[0] == null) question.addPanel();
      if (question.panels[0].questions.length == 0) return;
      panelQuestionNames.push(question.name);
      data += `export interface ${question.name} {\n`;
      const questions = question?.panels[0].questions;
      for (let i = 0; i < questions.length; i++) {
        const question = questions[i];
        panelQuestionNames.push(question.name);
        data += getTypescriptDefinitionLine(question);
      }
      data += "}\n";
    });

  data += `export interface SurveyInstance {\n`;
  survey
    .getAllQuestions(false, true)
    .filter(x => x.getType() !== "paneldynamic")
    .forEach(function(question) {
      if (panelQuestionNames.includes(question.name)) return;
      data += getTypescriptDefinitionLine(question);
    });
  data += "}\n";
  writeFileSync(filePath, data, { encoding: "utf8", flag: "a" });
};

export const generateSurveyModels = () => {
  addQuestionTypes(Survey);
  const survey = new Survey.SurveyModel(json);
  console.log(`Generating response, writing to file ${filePath}`);
  generateQuestionNamesEnum(survey);
  generateQuestionInterfaces(survey);
};

generateSurveyModels();
